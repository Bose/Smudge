\documentclass{article}
\usepackage{amsmath}
\usepackage{semantic}

\newcommand{\instantiates}{\operatorname{<:}}

\newcommand{\hastype}[3]{#1 \vdash #2 : #3}

\begin{document}
\section*{Type inference in smudge}
The types of events and side effects in smudge can be both explicit and
implicit, as functions can be supplied both with and without type hints.
Accordingly, types within a single module are inferred using a deterministic
type simplification algorithm.

To construct these rules, both the notation of natural deduction for type
inference and the notation for automata are useful here, with a slight
modification: events are considered to be composite, that is, they
are transitions composed of a sequence of side-effectful computation
statements, whose types can be non-uniform.  For clarity, the following
conventions are used:
\begin{itemize}
    \item $\Gamma$ refers to the environment of types
    \item $\tau$ refers to a type

    \item $\delta$ refers to a total transition function for a state and event
    \item $\check{\delta}$ refers to a named side-effectful partial transition
\end{itemize}

\subsection*{Subtype polymorphic unification rules}
The default unification method is to simplify the types using polymorphism.  It
is instructive to first consider a non-deterministic rule for simplification.
According to this rule, a simplified type is a type that is strictly more
general than either of two other types, such that these two types are subtypes
of it.
\[
    \inference[SimplifyNonDeterministic]
    {\hastype{\Gamma}{\check{\delta_1}}{\tau_1\times\ldots\times\tau_n\rightarrow\tau}\\
     \hastype{\Gamma}{\check{\delta_2}}{\tau_1'\times\ldots\times\tau_m'\rightarrow\tau'}\\
     \tau_1\times\ldots\times\tau_n\rightarrow\tau\instantiates\tau_1''\times\ldots\times\tau_k''\rightarrow\tau''\\
     \tau_1'\times\ldots\times\tau_m'\rightarrow\tau'\instantiates\tau_1''\times\ldots\times\tau_k''\rightarrow\tau''}
    {\hastype{\Gamma}{\textsc{simplify}(\check{\delta_1}, \check{\delta_2})}{\tau_1''\times\ldots\times\tau_k''\rightarrow\tau''}}
\]

However, this definition is insufficient to specify the actual result of type
unification, which requires a constraint solver.
\end{document}
