=================
Turnstile Example
=================

.. contents::

.. sectnum::

.. raw:: pdf

         PageBreak oneColumn
   
Simple Turnstile
================

In this tutorial, we'll be creating a simple turnstile program. It
will accept coin events, unlock itself, let a person walk through, and
lock itself. Here's a nice drawing of the basic state machine:

.. figure:: initial.png
    :width: 300

The source for this state machine, reproduced below, is available in
**initial.smudge**. You can see the essential elements of a smudge state
machine. The word ``turnstile`` is the name of the state machine. The
part inside the curly braces after the state machine's name is its
definition.

::

    turnstile
    {
       *locked // The * means it's the initial state.
        [
            coin --> unlocked
        ],
    
        unlocked
        [
            person --> locked
        ]
    }

Inside the state machine's definition, there are one or more states
separated by commas. The turnstile example has 2 states called
*locked* and *unlocked*. The initial state will be *locked* for this
state machine.

Each state has the events (also comma separated) that it handles
listed as transitions. A transition is, syntactically, an event name
followed by an arrow followed by a state name. The event causes the
state machine to go to the named state. In this example, the events
are *coin* and *person*. Note that not every event is handled by
every state. Smudge will generate an error if *coin* is sent to a
*turnstile* that's *unlocked*.

Generate Stubs
--------------

So now that we have some Smudge code, let's try building it and making
a program that works. First, make sure Smudge is somewhere in your
path. Then run Smudge on the example.

::

   smudge initial.smudge

This will generate some dot output (the picture above, see sidebar on
the next page), a C file and a pair of headers. They all get dropped
in the same directory as the .smudge file. Since this is a brand new
state machine, we can have Smudge generate some boilerplate with the
``--c-stubs`` command line option.

.. sidebar:: Install GraphViz

    Make sure to install GraphViz to generate this diagram; if
    GraphViz is missing, Smudge will not generate this dot output,
    and will exit with an error, so make sure to install it.

::

   smudge --c-stubs initial.smudge

That will generate an extra .c file called **initial_ext.c** This file
is for you to modify as necessary. It includes stubs of all the
functions that Smudge needs in order to work. Note that if you don't
do anything with these stubs, your state machine will not work. The
**broken.c** example file sends the *coin* and *person* events. Since the
stubs are empty, the state never changes.

.. sidebar:: On Round-Trips

    There are other code generation systems that support a thing
    called round-tripping. That's where you take the file generated by
    the tool, edit it, then those edits get incorporated into the
    tool's sources. In a round-tripped system, you can generate some
    code, tweak the generated code, then tweak the source for the
    generator and regenerate the code. The generated code will include
    both sets of tweaks.

    Smudge does not support round-tripping. There are currently no
    plans for Smudge to support round-tripping. Smudge's authors don't
    like the idea of editing the generated code, so Smudge is likely
    to never support round-tripping.

It's a good idea to copy the stubs to a new file so that if you
re-generate them Smudge won't overwrite the existing one. We will
explore what all the functions do later in this tutorial, but for now
look at **fixed.c** to see some minimal bodies for the stubs. If you
build and run it, you'll see that the state does indeed change in
response to events.

Most of the stubs aren't strictly necessary for Smudge to function. If
you don't want anything to happen when an unhandled event comes in,
you can leave ``SMUDGE_panic`` and ``SMUDGE_panic_print`` empty and
Smudge will still basically work. However, the
``turnstile_Send_Message`` function is required. Every state machine
has a ``_Send_Message`` function that accepts a struct by value. That
struct needs to be sent back to the state machine through the
corresponding ``_Handle_Message`` function. The simple implementation
(used in **fixed.c**) is to just call ``turnstile_Handle_Message``
from ``turnstile_Send_Message``. That approach has problems, but it
will work for now.

Use it
------

Now we can send the *coin* and *person* events by calling the
appropriate event functions. The functions take pointer arguments
which we'll leave NULL for now. The **events.c** example shows
this.

.. sidebar:: Debugging Functions

    The **events.c** example uses ``turnstile_Current_state_name`` to
    demonstrate that the state machine is transitioning states. The
    ``_Current_state_name`` function is generated for every state
    machine, and will return a string with the name of the appropriate
    machine's current state. Its prototype is generated in the state
    machine's **.h** file.

    In addition to this ``Current_state_name`` function that's
    generated for every state machine, Smudge uses the
    ``SMUDGE_panic_print`` function to indicate that a state machine
    has been sent an event that's unhandled in its current state. You
    can write whatever you want in the body of ``SMUDGE_panic_print``,
    but the three arguments can be passed straight to ``printf`` in
    order to generate a sensible error message.

    These functions require Smudge to generate a significant number of
    constant strings, which on some platforms will overtax limited
    resources. Since Smudge is designed for use on embedded systems,
    there's a way to turn these off. If you pass ``--c-no-debug`` to
    Smudge on the command line, the ``_Current_state_name`` functions
    will return empty strings (a single null character) and
    ``SMUDGE_panic_print`` will never be called. Instead, Smudge will
    call ``SMUDGE_panic`` when an unhandled event is received by a
    state machine. This function takes no arguments and can do
    whatever things ``SMUDGE_panic_print`` does that doesn't require
    knowledge of the current state and the event that triggered the
    error. This is a good place to put debugger traps.

Do Something
------------

So far, we have a state machine that can transition states, but it
doesn't do anything. For that, we need side effects. There are two
types of side effects in Smudge: C functions that are called directly
(@functions) and events. For now, we'll focus on @functions. The name
of an @function can be any valid C identifier for reasons that will
become apparent soon.

When a person walks through an unlocked turnstile, we'd like it to
play a sound. When a coin is inserted, it should flash some LEDs. To
add these features to our turnstile state machine, see
**side_effects.smudge**.

::

    turnstile
    {
       *locked // The * means it's the initial state.
        [
            coin -(@flashLEDs)-> unlocked
        ],
    
        unlocked
        [
            person -(@soundOkay)-> locked
        ]
    }

Note that the arrows have changed from ``-->`` to ``-(@function)->``. This is
a more general arrow. The full arrow syntax is ``-(`` followed by a
comma separated list of side effects (@functions and events) followed
by ``)->``. The ``-->`` syntax we've been using is shorthand for
``-()->``.

Now run Smudge again and look at **side_effects_ext.h**. Note that in
addition to the prototypes from **initial.smudge**, there are
prototypes for ``flashLEDs`` and ``soundOkay``. These functions have
to be added to main.c. Running Smudge with ``--c-stubs`` on
**initial.smudge** will generate stubs for these functions, too.

.. figure:: side_effects.png
    :width: 500

A simple program that implements these functions is in
**use_side_effects.c**. You can run it and see the side effects being
triggered.

Event Payloads
==============

You may have noticed that these side effect functions take pointers to
arguments whose types are left incomplete in
**side_effects.h**. Smudge won't ever put anything in these payloads,
but you can. Let's say that you want to pay attention to who's going
through your turnstile and play a nice customized greeting for them
when they pass. **payloads.c** uses the same **side_effects.smudge**
file, but adds some code to do just that.


.. raw:: pdf

         PageBreak oneColumn

Message Passing
===============

Before we go any further, it's time to talk about Smudge's message
passing mechanism. Smudge expects events it passes to the user through
``_Send_Message`` to be passed back to it through the corresponding
``_Handle_Message``. It expects order to be maintained, but they don't
have to be passed right back immediately. In fact, for nontrivial
state machines, it's bad to call ``_Handle_Message`` from within
``_Send_Message``.

The intent of these functions is for the system to queue up the
messages then hand them back when it's convenient. This lets the state
machine accept events from multiple threads, reduces the maximum stack
depth, and lets events be handled sanely even if their event handlers
send events.

The example code in **message_passing.c** uses a simple queue as a
proxy for the system's message queue. It implements a slightly more
realistic turnstile_Send_Message, and another loop that runs through
the queue and calls ``turnstile_Handle_Message`` and
``turnstile_Free_Message``.

Dynamic Allocation
------------------

You can compile **message_passing**, and depending on your system you
may even be able to run it. However, it has a fatal flaw:

::

   $ ./message_passing 
   turnstile[locked]: Unhandled event "person"
   Blinky blinky
   Segmentation fault: 11

Smudge passes an event wrapper in to ``turnstile_Send_Message`` by
value, but the ``turnstile_person`` function takes a pointer to an
event. In **message_passing.c**, that pointer was to values that lived
on the stack. Once that stack frame was gone, accessing those pointers
resulted in undefined behavior. Usually, though, it'll cause a
segfault.

The way around this, clearly, is to allocate those events on the heap
instead of using the stack. The next file, **dynamic_payloads.c**,
shows how Smudge handles dynamic memory allocation for event
payloads. After the event wrapper is passed to
``turnstile_Handle_Message``, it should be given to
``turnstile_Free_Message``. That function will, in turn, call
``SMUDGE_free``. As you can see if you run **dynamic_payloads**, the
pointers passed to ``SMUDGE_free`` are the same as those passed to
``turnstile_coin`` and ``turnstile_person``.

::

   $ make dynamic_payloads
   stack exec smudge -- --dot-fmt=Svg side_effects.smudge
   Wrote file "side_effects.svg"
   Wrote file "side_effects.h"
   Wrote file "side_effects.c"
   Wrote file "side_effects_ext.h"
   gcc -c -o side_effects.o -Wall -Wextra -Wno-unused-parameter side_effects.c
   gcc -c -o dynamic_payloads.o -Wall -Wextra -Wno-unused-parameter
   dynamic_payloads.c
   gcc -c -o queue.o -Wall -Wextra -Wno-unused-parameter queue.c
   gcc -o dynamic_payloads -Wall -Wextra -Wno-unused-parameter side_effects.o
   dynamic_payloads.o queue.o
   rm side_effects.c

   $ ./dynamic_payloads 
   Sending person event Thomas at 0x7f8b86c02760.
   Sending person event Nikola at 0x7f8b86c02750.
   turnstile[locked]: Unhandled event "person"
   Freeing Thomas at 0x7f8b86c02760
   Blinky blinky
   Welcome to the other side of the turnstile, Nikola.
   Freeing Nikola at 0x7f8b86c02750

Note that all events are passed to the same ``SMUDGE_free``
function. It should be able to handle any event sent to any state
machine. That almost certainly means ``NULL`` pointers, and if events
are ever allocated through methods other than ``malloc`` they will have
to be handled properly.

.. raw:: pdf

         PageBreak oneColumn

Wrapping Up
-----------

Memory management is tricky in C. If your program allocates memory for
a message wrapper, it has to free it after calling the appropriate
state machine's ``_Free_Message`` function to free the event
itself. If this seems confusing, you might want to spend some time
with the example (including the generated C code) until you understand
it.

The message passing scheme is one of the more complicated concepts to
understand in Smudge. Events get sent by user code with calls like
``turnstile_person(e)``. Then Smudge packages them up and hands them
right back to the user code in the form of a
``turnstile_Event_Wrapper_t`` passed to
``turnstile_Send_Message``. The events are sent as pointers, but the
wrappers come in by value. What the user code does next affects
Smudge's semantics.

If the user code behaves like the example in **dynamic_payloads.c**,
Smudge will have the semantics we use in this document. Events are
handled in order but not immediately. If an event is sent as a side
effect of another event, it will be handled after any state transition
caused by the original event.

If, instead, the ``turnstile_Send_Message`` function just calls
``turnstile_Handle_Message`` directly, like in **use_side_effects.c**,
that behavior changes. For simple state machines like
**side_effects.smudge**, this distinction probably doesn't
matter. However, for complex state machines you might use in
production code, this can cause some very weird bugs. It also tends to
increase your maximum stack depth, which can become a problem on
embedded systems.

Nonetheless, you define this aspect of Smudge's semantics. If you want
to make up a new data structure where the order of elements being
removed from it is not deterministic, then your events won't be
handled in a deterministic order.

Smudge does guarantee that @functions will always be handled right
away in the order in which they're called. That means that ``event
-(@a, otherEvent, @b)-> STATE`` will, with the behavior we're using in
dynamic_payloads.c, call ``a`` then ``b``, then handle *otherEvent*
from with in the state *STATE*.

Enter/Exit Functions
====================

Now our turnstile can accept a coin and allow a person through. It
doesn't actually lock or unlock though. To do that, we need to call
side effect functions when we enter the locked and unlocked
states. Between the name of a state machine and the ``[``, there is an
optional list of side effects surrounded by parentheses. These can be
@functions or events just like in arrows. Likewise, there's an
optional parenthesized list of @functions after the ``]``. The first list
is called immediately when the state is entered. The second list is
called after the state exits but before any other state is entered.

.. figure:: enter_exit.png
    :width: 500

Like with other lists of side effects, these functions are always
called in the order in which they're listed.

Unlike event side effects, @functions used on state enter and exit
don't accept any arguments. If you use the same function as an
enter/exit function and an event side effect, the generated prototype
for the function will accept no arguments and the event won't be
passed to the side effect function.

.. sidebar:: Side Effect Function Arguments

    All of the @functions we've looked at so far have taken a single
    event as an argument. State enter/exit functions take no
    arguments, since there's no associated event. This leads to a
    problem if you want to use the same function in both contexts. A
    similar problem arises when the same @function is called as the
    result of two different events.

    When Smudge detects this kind of inconsistency in the use of an
    @function, it decides that you weren't going to use the argument
    anyway and gets rid of it.

The files **enter_exit.smudge** and **use_enter_exit.c** add
lockedEnter and lockedExit as well as unlockedEnter to the state
machine. Now the turnstile can actually lock and unlock itself instead
of just waving as people go through. In the interest of simplicity,
we're going to put all that message passing stuff from the previous
chapter on the shelf. It will show up again later, but for now it's
mostly clutter.

Transitionless Events
=====================

Our turnstile is starting to look pretty nice, but what if a person
tries to go through it without paying? It would be good to have an
event that's handled by a state, but that doesn't cause a state
transition. We could put ``person --> locked`` in the locked state,
but that would cause it to exit and re-enter locked just because a
person tried to jump through. Since we don't want ``lockedEnter`` or
``lockedExit`` called, we need to use a different kind of event handler.

In addition to the arrow syntax, Smudge supports dash syntax to handle
an event without a state transition. A dash is just an arrow without a
``>`` character or a destination state. It looks like ``-(<side effect
list>)-``. Like with arrows, if the side effect list is empty you can
omit the parentheses.

.. figure:: transitionless.png
    :width: 700

The next example, **transitionless.smudge** and associated
**use_transitionless.c**, adds a second event handler (note the comma)
to the locked state and a new @function called ``soundAlarm``.

Transient States
================

Great, now our turnstile shames people who try to get through without
paying. Let's add a little state to power it up. Instead of starting
in locked, it should light up all its LEDs in a test pattern then go
straight to locked. This new state is called a transient state because
it doesn't stay around long enough to ever get any events.

.. figure:: transient.png
   :width: 700

The **transient.smudge** and **use_transient.c** example files add
this little state and a message to indicate that the turnstile is
powering up.

Multiple State Machines
=======================

The turnstile has been running nicely for a few days now, and the
customer (a subway system) is very happy. Wait a second, they say
they've been getting less money than expected and metal slugs are
piling up in the coin bin! That's no good, we need to validate those
coins before accepting them!

Smudge allows multiple state machines to be defined in the same
file. **multisim.c** and **msm.smudge** add a new simple single-state
machine to validate coins and deal with fakes. This is quite a bit of
new code, but the only really new piece of syntax is sending an event
as a side effect to a different state machine.

.. figure:: msm.png
   :width: 100%

The C code is a little more complicated, since we now have 2 different
machines to queue and dispatch messages for. On a real system, each of
these can have its own message queue, or they can share the system's
message queue like in the example.

.. sidebar:: Naming Things

   It is well known that the 2 hardest things in programming are cache
   invalidation, naming things, and off by one errors. Smudge lets you
   name things with a pretty wide character set. Events, states, and
   state machine names can contain characters not found in C
   identifiers like ``My-favorite-state-machine`` or even be quoted
   strings with a big character set like ``"Some (event) or other,
   +/-"``. When Smudge converts these things to C, it has to mangle
   the names into something that fits within the set of valid C
   identifiers.

   The precise way in which Smudge mangles names is not important for
   this tutorial, but there are a few properties that you might want
   to keep in mind. First, you never need to see the mangled names of
   states. If you want to name a state ``"The $%#!@ state"``, you'll be
   able to call ``SM_Current_state_name()`` and get that string back.

   However, for the names of your state machines, the mangling
   matters. If you use a state machine name that begins with a number,
   Smudge will generate an invalid identifier and it won't compile. If
   you use any other character but a letter to begin the name of your
   state machine, Smudge will mangle its name into something that
   begins with an underscore. Since the C standard reserves most
   symbols beginning with underscores, this could lead to undefined
   behavior. Use names for your state machines that begin with
   letters.

Syntactic Shortcuts
===================

You can use what you know now to generate anything Smudge can
generate. These next two sections cover some syntactic sugar that
Smudge provides to make your state machines more maintainable.

Default States
--------------

What if we want to handle a particular event the same regardless of
the current state? If someone shakes the turnstile, it should give off
a warning regardless of the current state of the machine. We could put
``tilt -(@soundAlarm)-`` in every state, but that's error prone and
nightmarish to maintain. Instead, there's a special state called the
*any-state*. Its name is a single underscore (``_``). If an event is
not specified in the current state, but it is specified in the
any-state, it will be handled according to its handler in the
any-state. An event that's specified in both will be handled by the
current state's handler.

.. figure:: default_states.png
   :width: 100%

The files **default_states.smudge** and **any_state.c** show some
extra code to handle tilting. Note that the ``soundAlarm`` @function has
had its signature changed because it's called in two incompatible
contexts. In this example, tilting the machine will cause it to eat
any money that's been inserted. They probably deserve it.

Default Events
--------------

Up until now, an unhandled event will cause the state machine to quit
with an error. That's not very friendly. If we have a state where we
don't want to crash on events that aren't handled explicitly, but want
to take the same action on all of them, we can use the *any-event*.

Since the *any-event* and *any-state* both cause default behavior,
there's a defined precedence order. Named events in named states are
always handled. If that doesn't exist for a given event/state
combination, named events in the *any-state* are handled next. If an
event is not named in the current or *any* state, it will be handled
by the *any-event* handler in the current state. If there isn't one of
those, it gets handled by an *any-event* handler in the
*any-state*. Here's a handy table with that precedence order. In
general, named things take precedence over unnamed things.

+-------+-------+
| state | event |
+=======+=======+
| named | named |
+-------+-------+
|  any  | named |
+-------+-------+
| named |  any  |
+-------+-------+
|  any  |  any  |
+-------+-------+

Like the any-state, the any-event's name is a single underscore
character. **any_event.c** and **default_events.smudge** show the
any-event in action. Since named event handlers take priority over
any-event handlers, we need to explicitly handle all the events from
the any-state in a state with the any-event.
